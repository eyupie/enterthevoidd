<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TJL2LTC5MD"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-TJL2LTC5MD');
    </script>
    <link rel="manifest" href="/manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VOID</title>
    <style>
        /* Import a futuristic, legible font */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: white;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            background: #000;
            overflow: hidden;
            user-select: none;
            cursor: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* Ensure the canvas covers the whole container */
        }

        /* General UI styling for screens, messages, and menus */
        .ui-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            color: #00FFFF; /* Cyan */
            text-shadow: 0 0 15px #00FFFF;
            font-size: clamp(2rem, 8vw, 4rem);
            margin-bottom: 20px;
        }

        .game-info {
            font-size: clamp(0.8rem, 3vw, 1.2rem);
            margin-bottom: 30px;
            color: #00FF7F; /* Spring Green */
        }

        .button {
            padding: 12px 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.9rem, 4vw, 1.1rem);
            background: linear-gradient(135deg, #00FFFF 0%, #00FF7F 100%);
            color: #000;
            border: 2px solid #00FFFF;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6), 0 0 20px rgba(0, 255, 127, 0.4);
            transition: all 0.2s ease-in-out;
            text-transform: uppercase;
            font-weight: 700;
        }

        .button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #00FFFF, 0 0 30px #00FF7F;
        }
        
        .button:active {
            transform: scale(0.98);
        }

        /* Score and UI elements */
        #score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00FF7F;
            font-size: clamp(1rem, 3vw, 1.5rem);
            z-index: 5;
            text-shadow: 0 0 5px #00FF7F;
        }
        
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 25px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #FF4500;
            border-radius: 8px;
            color: #FF4500;
            font-size: clamp(1rem, 4vw, 1.5rem);
            text-shadow: 0 0 10px #FF4500;
            z-index: 10;
            display: none;
        }

        /* Mobile specific style for interaction area */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to canvas if needed, but not necessary here */
        }
        
    </style>
</head>
<body>

<div id="game-container">
    <div id="score-display">SCORE: 0</div>
    <div id="message-box"></div>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Start Screen -->
    <div id="startScreen" class="ui-screen">
        <h1>VOID</h1>
        <div class="game-info">
            <p>Control the reticle to destroy the incoming segments before they complete the target shape.</p>
            <p>Desktop: Mouse movement and click (Fire).</p>
            <p>Mobile: Device tilt/gyro (Move) and tap (Fire).</p>
        </div>
        <button id="startButton" class="button">Start Calibration</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="ui-screen hidden">
        <h1>GAME OVER</h1>
        <div class="game-info">
            <p>Final Score: <span id="finalScore">0</span></p>
            <p id="bestScoreText">Best Score: 0</p>
        </div>
        <button id="restartButton" class="button">Restart VOID</button>
    </div>
    
    <div id="ui-layer" class="hidden">
        <!-- Optional Mobile Fire button overlay - not strictly needed if tap works on canvas -->
    </div>
</div>

<script type="module">
    // Helper function to convert base64 audio to ArrayBuffer for Web Audio API
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    // Helper function to convert raw PCM data (Int16Array) to a WAV Blob
    function pcmToWav(pcmData, sampleRate) {
        const numChannels = 1;
        const sampleBits = 16;
        const bytesPerSample = sampleBits / 8;
        const blockAlign = numChannels * bytesPerSample;
        const byteRate = sampleRate * blockAlign;
        const dataSize = pcmData.byteLength;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);
        let offset = 0;

        function writeString(str) {
            for (let i = 0; i < str.length; i++) {
                view.setUint8(offset++, str.charCodeAt(i));
            }
        }

        // RIFF chunk
        writeString('RIFF');
        view.setUint32(offset, 36 + dataSize, true); offset += 4;
        writeString('WAVE');

        // FMT chunk
        writeString('fmt ');
        view.setUint32(offset, 16, true); offset += 4; // Sub-chunk size
        view.setUint16(offset, 1, true); offset += 2;  // Audio format (PCM = 1)
        view.setUint16(offset, numChannels, true); offset += 2;
        view.setUint32(offset, sampleRate, true); offset += 4;
        view.setUint32(offset, byteRate, true); offset += 4;
        view.setUint16(offset, blockAlign, true); offset += 2;
        view.setUint16(offset, sampleBits, true); offset += 2;

        // DATA chunk
        writeString('data');
        view.setUint32(offset, dataSize, true); offset += 4;

        // Write PCM data
        for (let i = 0; i < pcmData.length; i++) {
            view.setInt16(offset, pcmData[i], true);
            offset += 2;
        }

        return new Blob([view], { type: 'audio/wav' });
    }

    // --- GAME INITIALIZATION ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const scoreDisplay = document.getElementById('score-display');
    const finalScoreSpan = document.getElementById('finalScore');
    const bestScoreText = document.getElementById('bestScoreText');
    const messageBox = document.getElementById('message-box');

    // Constants for Game Logic
    const TARGET_RADIUS_MIN = 80;
    const TARGET_RADIUS_MAX = 200;
    const SEGMENTS_MIN = 5;
    const SEGMENTS_MAX = 12;
    const SEGMENT_SPEED_BASE = 0.0005; // Base angle speed
    const SEGMENT_LERP_SPEED = 0.05; // Speed for segments to snap to angle

    // Constants for mobile/gyro control (ADJUSTED FOR LESS SENSITIVITY)
    const GYRO_SENSITIVITY = 0.25; // Max movement range is 25% of the screen width/height from the center
    const GYRO_TILT_RANGE = 20; // Degrees of tilt considered 'full' movement (less than 90)

    // Game state variables
    let target = null;
    let score = 0;
    let bestScore = localStorage.getItem('voidBestScore') ? parseInt(localStorage.getItem('voidBestScore')) : 0;
    let gameOver = false;
    let isPlaying = false;
    let lastTime = 0;
    let deltaTime = 0;
    let audioCtx;
    let level = 1;

    // Player (Ship/Reticle)
    let shipTargetX = 0;
    let shipTargetY = 0;
    // Ship radius ADJUSTED for smaller size
    let ship = { x: 0, y: 0, radius: 12, color: '#00FFFF', angle: 0 }; 
    let projectiles = [];

    // Mobile/Gyro State
    let isMobile = false;
    let gyroAlpha = 0;
    let gyroBeta = 0;
    let gyroGamma = 0;
    let touchEnabled = false; // Flag for touch interaction

    // --- UTILITY FUNCTIONS ---

    function lerp(start, end, t) {
        return start + (end - start) * t;
    }

    function dist(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    function mapRange(value, inMin, inMax, outMin, outMax) {
        return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    }

    function showMessage(text, duration = 1500, color = '#FF4500') {
        messageBox.textContent = text;
        messageBox.style.color = color;
        messageBox.style.borderColor = color;
        messageBox.style.textShadow = `0 0 10px ${color}`;
        messageBox.style.display = 'block';
        setTimeout(() => {
            messageBox.style.display = 'none';
        }, duration);
    }

    // --- AUDIO GENERATION AND PLAYBACK ---
    
    const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=";
    const apiKey = ""; 

    async function playTextToSpeech(text, voiceName = "Kore") {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Resume audio context if suspended (needed for first interaction on some browsers)
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        
        const payload = {
            contents: [{ parts: [{ text: text }] }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: voiceName }
                    }
                }
            },
            model: "gemini-2.5-flash-preview-tts"
        };

        try {
            const response = await fetch(API_URL + apiKey, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                console.error("TTS API call failed:", response.status, await response.text());
                return;
            }

            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                // Extract sample rate from mimeType, e.g., audio/L16;rate=24000
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                const audioUrl = URL.createObjectURL(wavBlob);

                const audio = new Audio(audioUrl);
                audio.play().catch(e => console.error("Audio playback failed:", e));

                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl); // Clean up the Blob URL
                };
            } else {
                console.error("No valid audio data received from TTS API.");
            }
        } catch (error) {
            console.error("Error fetching TTS audio:", error);
        }
    }

    // --- GAME OBJECTS & LOGIC ---

    function createTarget() {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = Math.floor(mapRange(level, 1, 10, TARGET_RADIUS_MAX, TARGET_RADIUS_MIN));
        const numSegments = Math.floor(mapRange(level, 1, 10, SEGMENTS_MIN, SEGMENTS_MAX));
        const segmentAngle = (Math.PI * 2) / numSegments;
        
        let segments = [];
        let totalSpeed = SEGMENT_SPEED_BASE + (level * 0.00005);

        for (let i = 0; i < numSegments; i++) {
            segments.push({
                startAngle: i * segmentAngle,
                endAngle: (i + 1) * segmentAngle,
                targetStartAngle: i * segmentAngle,
                targetEndAngle: (i + 1) * segmentAngle,
                isDestroyed: false,
                color: `hsl(${i * (360 / numSegments)}, 100%, 50%)`,
                scale: 0.1 + (0.9 * Math.random()), // initial scale, between 10% and 100%
                scaleSpeed: totalSpeed * (0.8 + 0.4 * Math.random()), // slightly varied speed
                isComplete: false,
                centerX: (Math.cos(i * segmentAngle + segmentAngle/2)),
                centerY: (Math.sin(i * segmentAngle + segmentAngle/2)),
            });
        }

        return { cx, cy, radius, numSegments, segmentAngle, segments, angle: 0, speed: totalSpeed, innerRadius: radius / 3 };
    }

    function createProjectile(x, y, vx, vy) {
        return { 
            x, 
            y, 
            vx, 
            vy, 
            radius: 4, 
            color: '#FFD700', // Gold
            life: 60, // frames
            damage: 1
        };
    }

    function updateProjectiles() {
        projectiles = projectiles.filter(p => p.life > 0);
        projectiles.forEach(p => {
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.life--;
        });
    }

    function checkCollision() {
        if (!target) return;

        projectiles.forEach(p => {
            if (p.life <= 0) return; // Already expired

            target.segments.forEach(seg => {
                if (seg.isDestroyed || seg.isComplete) return;

                const centerAngle = (seg.startAngle + seg.endAngle) / 2;
                const distance = dist(p.x, p.y, target.cx, target.cy);

                // Check distance from center
                if (distance > target.innerRadius && distance < target.radius) {
                    
                    // Check angle relative to target center
                    let collisionAngle = Math.atan2(p.y - target.cy, p.x - target.cx);
                    
                    // Normalize collisionAngle to match segment angles (0 to 2*PI)
                    collisionAngle -= target.angle; 
                    collisionAngle = (collisionAngle + 2 * Math.PI) % (2 * Math.PI);

                    if (collisionAngle >= seg.startAngle && collisionAngle <= seg.endAngle) {
                        seg.isDestroyed = true;
                        p.life = 0; // Destroy projectile
                        score += 10;
                        scoreDisplay.textContent = `SCORE: ${score}`;
                        playTextToSpeech('Segment Destroyed', 'Fenrir');
                    }
                }
            });
        });
    }

    function updateTarget() {
        if (!target) return;

        target.segments.forEach(seg => {
            if (!seg.isDestroyed && !seg.isComplete) {
                // Advance the scale toward 1 (completion)
                seg.scale = lerp(seg.scale, 1, seg.scaleSpeed * deltaTime);
                
                if (seg.scale > 0.995) {
                    seg.scale = 1;
                    seg.isComplete = true;
                    // Check for Game Over immediately
                    checkGameOver(); 
                }
            }
        });
        
        // Rotate the entire target object
        target.angle += target.speed * deltaTime;
        target.angle %= (Math.PI * 2);
    }
    
    function checkGameOver() {
        if (!target) return;

        const allDestroyed = target.segments.every(seg => seg.isDestroyed || seg.isComplete);
        if (allDestroyed) {
            // Check if game over condition (any segment completed) was met
            const completedSegments = target.segments.filter(seg => seg.isComplete).length;
            
            if (completedSegments > 0) {
                endGame();
            } else {
                // All segments destroyed before completion - level up!
                levelUp();
            }
        }
    }
    
    function levelUp() {
        level++;
        showMessage(`LEVEL ${level} // TARGET ACQUIRED`, 2000, '#00FFFF');
        playTextToSpeech(`Level ${level} achieved. New target initializing.`, 'Orus');
        target = createTarget();
    }
    
    function drawShip() {
        ctx.beginPath();
        // Draw the central circle (reticle)
        ctx.arc(ship.x, ship.y, ship.radius, 0, Math.PI * 2);
        ctx.strokeStyle = ship.color;
        ctx.lineWidth = 2;
        ctx.shadowColor = ship.color;
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.shadowBlur = 0; // Reset shadow for other drawings

        // Draw crosshairs
        ctx.strokeStyle = ship.color;
        ctx.lineWidth = 1;
        const size = ship.radius + 5;
        
        // Horizontal line
        ctx.beginPath();
        ctx.moveTo(ship.x - size, ship.y);
        ctx.lineTo(ship.x - ship.radius/3, ship.y);
        ctx.moveTo(ship.x + ship.radius/3, ship.y);
        ctx.lineTo(ship.x + size, ship.y);
        ctx.stroke();

        // Vertical line
        ctx.beginPath();
        ctx.moveTo(ship.x, ship.y - size);
        ctx.lineTo(ship.x, ship.y - ship.radius/3);
        ctx.moveTo(ship.x, ship.y + ship.radius/3);
        ctx.lineTo(ship.x, ship.y + size);
        ctx.stroke();
    }

    function drawProjectiles() {
        projectiles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawTarget() {
        if (!target) return;
        
        const cx = target.cx;
        const cy = target.cy;
        const R = target.radius;
        const r = target.innerRadius;
        const angle = target.angle;

        // Draw static inner core
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fillStyle = '#0F0F0F'; // Dark gray core
        ctx.fill();
        ctx.strokeStyle = '#00FF7F'; // Spring Green outline
        ctx.lineWidth = 1;
        ctx.shadowColor = '#00FF7F';
        ctx.shadowBlur = 5;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Draw segments
        target.segments.forEach(seg => {
            if (seg.isComplete) {
                // Draw a complete segment as a solid block (Game Over condition)
                ctx.beginPath();
                ctx.arc(cx, cy, R, seg.startAngle + angle, seg.endAngle + angle);
                ctx.lineTo(cx, cy);
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 69, 0, 0.5)'; // Red-Orange transparent fill
                ctx.fill();
                ctx.strokeStyle = '#FF4500';
                ctx.lineWidth = 2;
                ctx.stroke();
                
            } else if (!seg.isDestroyed) {
                // Interpolate segment angle (for smooth rotation effect)
                seg.startAngle = lerp(seg.startAngle, seg.targetStartAngle, SEGMENT_LERP_SPEED * deltaTime);
                seg.endAngle = lerp(seg.endAngle, seg.targetEndAngle, SEGMENT_LERP_SPEED * deltaTime);

                // Calculate the outer arc radius based on scale
                const currentR = r + (R - r) * seg.scale;

                // Draw the segment
                ctx.beginPath();
                ctx.arc(cx, cy, currentR, seg.startAngle + angle, seg.endAngle + angle);
                ctx.arc(cx, cy, r, seg.endAngle + angle, seg.startAngle + angle, true);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 255, 127, 0.05)'; // Very subtle fill
                ctx.fill();
                ctx.strokeStyle = seg.color;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        });
    }

    function drawConsole() {
        if (!target) return;
        
        const cx = target.cx;
        const cy = target.cy;
        const innerRadius = target.innerRadius;
        const outerRadius = Math.max(canvas.width, canvas.height) * 0.7; // Outer bound for console lines
        
        // Line width ADJUSTED for better visibility on mobile
        ctx.lineWidth = 2.5; 
        ctx.strokeStyle = '#00FF7F'; // Spring Green
        // Shadow blur ADJUSTED for better visibility
        ctx.shadowColor = '#00FF7F';
        ctx.shadowBlur = 12;

        target.segments.forEach(seg => {
            if (seg.isDestroyed || seg.isComplete) return;

            // Use the lerped angles
            const angle1 = seg.startAngle + target.angle;
            const angle2 = seg.endAngle + target.angle;
            
            // Outer point of segment
            const P1_O = { x: cx + Math.cos(angle1) * outerRadius, y: cy + Math.sin(angle1) * outerRadius };
            const P2_O = { x: cx + Math.cos(angle2) * outerRadius, y: cy + Math.sin(angle2) * outerRadius };

            // Inner point of segment (on the inner radius of the target)
            const P1_I = { x: cx + Math.cos(angle1) * innerRadius, y: cy + Math.sin(angle1) * innerRadius };
            const P2_I = { x: cx + Math.cos(angle2) * innerRadius, y: cy + Math.sin(angle2) * innerRadius };

            // Draw the radial lines
            ctx.beginPath();
            ctx.moveTo(P1_I.x, P1_I.y);
            ctx.lineTo(P1_O.x, P1_O.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(P2_I.x, P2_I.y);
            ctx.lineTo(P2_O.x, P2_O.y);
            ctx.stroke();
            
            // Draw the scale indicator line inside the segment (subtle progress bar)
            const midAngle = (angle1 + angle2) / 2;
            const scaleLength = target.radius - innerRadius;
            const currentScalePoint = innerRadius + scaleLength * seg.scale;
            
            ctx.beginPath();
            ctx.moveTo(cx + Math.cos(midAngle) * innerRadius, cy + Math.sin(midAngle) * innerRadius);
            ctx.lineTo(cx + Math.cos(midAngle) * currentScalePoint, cy + Math.sin(midAngle) * currentScalePoint);
            ctx.strokeStyle = seg.color; // Use segment color for progress line
            ctx.stroke();
            
        });
        
        // Draw the three-point targeting indicator around the ship 
        ctx.strokeStyle = '#00FFFF'; // Cyan
        ctx.shadowColor = '#00FFFF';
        
        target.segments.forEach(seg => {
            if (seg.isDestroyed || seg.isComplete) return;

            const r1 = target.innerRadius;
            const r2 = target.radius;
            const scale1 = seg.scale;
            const scale2 = seg.scale * 0.9; // Slight variance
            
            // Use the lerped angles
            const angle1 = seg.startAngle + target.angle;
            const angle2 = seg.endAngle + target.angle;
            const midAngle = (angle1 + angle2) / 2;
            
            // Use current segment scale to determine where the point is drawn
            const innerRadius1 = r1 + (r2 - r1) * scale1;
            const innerRadius2 = r1 + (r2 - r1) * scale2;
            
            // P3_I (Center-ish point)
            const P3_I = { 
                x: cx + Math.cos(midAngle) * innerRadius2, 
                y: cy + Math.sin(midAngle) * innerRadius2 
            };
            
            // P1_I and P2_I (Corner points)
            const P1_I = { 
                x: cx + Math.cos(angle1) * innerRadius1, 
                y: cy + Math.sin(angle1) * innerRadius1 
            };
            
            const P2_I = { 
                x: cx + Math.cos(angle2) * innerRadius1, 
                y: cy + Math.sin(angle2) * innerRadius1 
            };

            ctx.beginPath();
            ctx.moveTo(P3_I.x, P3_I.y);
            ctx.lineTo(P2_I.x, P2_I.y);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(P3_I.x, P3_I.y);
            ctx.lineTo(P1_I.x, P1_I.y);
            ctx.stroke();
        });
        ctx.shadowBlur = 0;
    }


    // --- GAME FLOW & EVENTS ---

    function initGame() {
        // Set canvas size
        canvas.width = gameContainer.clientWidth;
        canvas.height = gameContainer.clientHeight;
        
        // Initial state
        level = 1;
        score = 0;
        gameOver = false;
        projectiles = [];
        scoreDisplay.textContent = `SCORE: ${score}`;
        ship.x = canvas.width / 2;
        ship.y = canvas.height / 2;
        shipTargetX = ship.x;
        shipTargetY = ship.y;
        target = createTarget();

        // Detect mobile based on screen size or touch events
        isMobile = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
        
        // Initialize audio context
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    function startGame() {
        initGame(); 
        
        requestGyroPermission();
        
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('ui-layer').classList.remove('hidden');
        gameContainer.style.cursor = 'none';
        
        // Resume audio context if suspended (needed for first interaction on some browsers)
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        isPlaying = true;
        lastTime = performance.now();
        gameLoop(lastTime);
        
        playTextToSpeech('Target lock initiated. Protect the core.', 'Kore');
    }
    
    function endGame() {
        isPlaying = false;
        gameOver = true;
        document.getElementById('gameOverScreen').classList.remove('hidden');
        finalScoreSpan.textContent = score;
        
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('voidBestScore', bestScore);
            bestScoreText.textContent = `NEW BEST SCORE: ${bestScore}`;
            playTextToSpeech('Critical failure. New high score recorded.', 'Charon');
        } else {
            bestScoreText.textContent = `Best Score: ${bestScore}`;
            playTextToSpeech('Critical failure. Systems offline.', 'Charon');
        }
        
        gameContainer.style.cursor = 'default';
    }

    // --- INPUT HANDLERS ---
    
    function fireProjectile(x, y) {
        if (!isPlaying) return;

        const angle = Math.atan2(y - ship.y, x - ship.x);
        const speed = 15;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        
        projectiles.push(createProjectile(ship.x, ship.y, vx, vy));
        // Add a simple fire sound here if using Tone.js, otherwise a console message
        // console.log("Fire!");
    }

    function onMouseMove(event) {
        if (isMobile) return;
        shipTargetX = event.clientX;
        shipTargetY = event.clientY;
    }

    function onMouseClick(event) {
        if (isMobile || !isPlaying) return;
        fireProjectile(event.clientX, event.clientY);
    }
    
    function onTouchMove(event) {
        if (!isPlaying || event.touches.length === 0) return;
        // In mobile mode, we ignore touchmove for ship control, relying on gyro
        // This prevents conflicting input.
        event.preventDefault();
    }
    
    function onTouchStart(event) {
        if (!isPlaying || !isMobile) return;
        event.preventDefault();
        
        // Fire logic: tap the screen to fire toward the touch point (first touch only)
        const touch = event.touches[0];
        fireProjectile(touch.clientX, touch.clientY);
    }

    function onDeviceOrientation(event) {
        if (!isMobile || !isPlaying || event.alpha === null) return;
        
        gyroAlpha = event.alpha;
        gyroBeta = event.beta; // Tilt front/back
        gyroGamma = event.gamma; // Tilt left/right
    }

    function requestGyroPermission() {
        if (isMobile && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', onDeviceOrientation);
                        showMessage('Gyro controls active.', 1500, '#00FFFF');
                    } else {
                        showMessage('Gyro permission denied. Tap to fire.', 3000, '#FF4500');
                    }
                })
                .catch(error => {
                    console.error("Device orientation request failed:", error);
                    showMessage('Could not activate motion controls.', 3000, '#FF4500');
                    window.addEventListener('deviceorientation', onDeviceOrientation); // Fallback
                });
        } else if (isMobile) {
            // Non-iOS devices where requestPermission is not needed
            window.addEventListener('deviceorientation', onDeviceOrientation);
            showMessage('Motion controls enabled.', 1500, '#00FFFF');
        }
    }


    // --- MAIN GAME LOOP ---

    function update(time) {
        deltaTime = (time - lastTime) / 1000; // Time in seconds
        lastTime = time;

        if (isMobile) {
            // Apply reduced sensitivity for mobile controls
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Define the max movement range from center based on sensitivity factor
            const maxMovementRangeX = canvas.width * GYRO_SENSITIVITY;
            const maxMovementRangeY = canvas.height * GYRO_SENSITIVITY;
            
            const tiltRange = GYRO_TILT_RANGE;

            // Clamp gyro values to the effective tilt range
            const effectiveGamma = Math.min(Math.max(gyroGamma, -tiltRange), tiltRange);
            const effectiveBeta = Math.min(Math.max(gyroBeta, -tiltRange), tiltRange);
            
            // Map clamped tilt to movement delta, and add to center
            // gamma (left/right tilt) controls X movement
            const mappedX = centerX + (effectiveGamma / tiltRange) * maxMovementRangeX;
            // beta (front/back tilt) controls Y movement (inverted for natural feel)
            const mappedY = centerY + (effectiveBeta / tiltRange) * maxMovementRangeY * -1; // -1 for intuitive Y axis

            shipTargetX = mappedX;
            shipTargetY = mappedY;
        }

        // Smooth ship movement towards target (desktop or mobile)
        ship.x = lerp(ship.x, shipTargetX, 0.15); 
        ship.y = lerp(ship.y, shipTargetY, 0.15);

        // Game logic updates
        updateTarget();
        updateProjectiles();
        checkCollision();
        checkGameOver(); // Redundant check, but good for safety
    }

    function draw() {
        // Clear canvas
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw all game elements
        drawConsole();
        drawTarget();
        drawProjectiles();
        drawShip();
    }

    function gameLoop(time) {
        if (!isPlaying) return;

        update(time);
        draw();

        requestAnimationFrame(gameLoop);
    }
    
    // --- EVENT LISTENERS ---
    
    window.addEventListener('resize', () => {
        canvas.width = gameContainer.clientWidth;
        canvas.height = gameContainer.clientHeight;
        // Recalculate center for target
        if (target) {
            target.cx = canvas.width / 2;
            target.cy = canvas.height / 2;
        }
        // Recalculate shipTarget if desktop
        if (!isMobile) {
            shipTargetX = ship.x; // Keep in place
            shipTargetY = ship.y;
        } else {
             // Re-center ship on resize for mobile
            ship.x = canvas.width / 2;
            ship.y = canvas.height / 2;
        }
    });
    
    document.getElementById('startButton').addEventListener('click', startGame);
    document.getElementById('restartButton').addEventListener('click', startGame);

    gameContainer.addEventListener('mousemove', onMouseMove);
    gameContainer.addEventListener('click', onMouseClick);
    
    // Mobile touch events
    gameContainer.addEventListener('touchstart', onTouchStart, { passive: false });
    gameContainer.addEventListener('touchmove', onTouchMove, { passive: false });


    // Initial setup on load
    window.onload = function() {
        initGame();
        // Check initial best score
        if (document.getElementById('bestScoreText')) {
            document.getElementById('bestScoreText').textContent = `Best Score: ${bestScore}`;
        }
    }

</script>
</body>
</html>
