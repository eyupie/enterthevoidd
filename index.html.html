<!DOCTYPE html>
<html lang="en">
<head>
        <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TJL2LTC5MD"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-TJL2LTC5MD');
    </script>
    <link rel="manifest" href="/manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: white;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            background: #000;
            overflow: hidden;
            user-select: none;
            cursor: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .score-container {
            text-align: left;
        }

        .score-label {
            font-size: 14px;
            color: #aaa;
            letter-spacing: 2px;
        }

        .score-val {
            font-size: 48px;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .speed-meter {
            text-align: right;
        }

        .speed-val {
            font-size: 24px;
            color: #00ffff;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            z-index: 20;
            transition: opacity 0.3s;
            padding: 20px;
            box-sizing: border-box;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 64px;
            margin: 0;
            letter-spacing: 5px;
            background: linear-gradient(90deg, #ff0055, #00ffff, #00ff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
        }

        /* Mobile responsive title */
        @media (max-width: 600px) {
            h1 {
                font-size: 36px;
                letter-spacing: 2px;
            }
            
            .game-over-title {
                font-size: 28px !important;
                letter-spacing: 1px !important;
                line-height: 1.2;
                word-break: break-word;
            }
        }

        p {
            color: #ccc;
            font-size: 18px;
            margin-top: 10px;
            max-width: 500px;
            text-align: center;
            line-height: 1.6;
        }

        .btn {
            margin-top: 40px;
            padding: 20px 60px;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            background: transparent;
            border: 3px solid #fff;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }

        .controls-hint {
            margin-top: 30px;
            font-size: 14px;
            color: #666;
            display: flex;
            gap: 20px;
        }

        .key {
            border: 1px solid #666;
            padding: 5px 10px;
            border-radius: 4px;
            color: #aaa;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" class="ui-layer hidden">
        <div class="hud-top">
            <div class="score-container">
                <div class="score-label">DISTANCE</div>
                <div class="score-val" id="scoreDisplay">0</div>
            </div>
            <div class="speed-meter">
                <div class="score-label">VELOCITY</div>
                <div class="speed-val" id="speedDisplay">MACH 1</div>
            </div>
        </div>
    </div>

    <div id="startScreen" class="screen">
        <h1>VOID</h1>
        <p>Enter the void. Get lost.</p>
        
        <div class="controls-hint">
            <span><span class="key">TILT / CURSOR</span> STEER SHIP</span>
        </div>

        <button class="btn" onclick="startGame()">ENTER THE VOID</button>
    </div>

    <div id="gameOverScreen" class="screen hidden">
        <h1 class="game-over-title" style="font-size: 48px; color: #ff0055; -webkit-text-fill-color: #ff0055;">CATASTROPHIC DENSITY</h1>
        <p>You reached <span id="finalScore" style="color:white; font-weight:bold;">0</span>m</p>
        <button class="btn" onclick="resetGame()">RESTART</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');

const SIDES = 6;
const FOV = 800;
const SEGMENT_DEPTH = 30;
const WALL_THICKNESS = 0.8;
const TUNNEL_RADIUS = 300;
const MAX_PATH_DEVIATION = 150;
const ANCHOR_SPACING = SEGMENT_DEPTH * 10;

let WIDTH, HEIGHT;

let gameState = 'START';
let score = 0;
let speed = 0;
const BASE_SPEED = 8; 
let hue = 0;

let playerX = 0;
let playerY = 0;
let targetX = 0;
let targetY = 0;

const SENSITIVITY_SCALE = 0.5;
const SMOOTHING_FACTOR = 0.15;

// Gyroscope variables
let isGyroActive = false;
let gyroBaseX = 0;
let gyroBaseY = 0;
const GYRO_SENSITIVITY = 3.0; // Adjust tilt sensitivity

let path = [];

const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    const now = audioCtx.currentTime;

    if (type === 'crash') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
    }
}

function resize() {
    WIDTH = canvas.parentElement.clientWidth;
    HEIGHT = canvas.parentElement.clientHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    
    playerX = Math.max(-WIDTH/2, Math.min(WIDTH/2, playerX));
    playerY = Math.max(-HEIGHT/2, Math.min(HEIGHT/2, playerY));
}
window.addEventListener('resize', resize);
resize();

function generateNextPathPoint() {
    const latestAnchor = path.filter(p => p.isAnchor).sort((a, b) => b.z - a.z)[0] || 
                         { z: -ANCHOR_SPACING, centerX: 0, centerY: 0, rotation: 0, isAnchor: true };
                         
    const nextZ = latestAnchor.z + ANCHOR_SPACING;

    const newX = latestAnchor.centerX + (Math.random() - 0.5) * 200;
    const newY = latestAnchor.centerY + (Math.random() - 0.5) * 200;
    
    const clampedX = Math.max(-MAX_PATH_DEVIATION, Math.min(MAX_PATH_DEVIATION, newX));
    const clampedY = Math.max(-MAX_PATH_DEVIATION, Math.min(MAX_PATH_DEVIATION, newY));

    const newRotation = latestAnchor.rotation + (Math.random() - 0.5) * 0.5;

    path.push({
        z: nextZ,
        centerX: clampedX,
        centerY: clampedY,
        rotation: newRotation,
        isAnchor: true 
    });

    path.sort((a, b) => a.z - b.z);
}

function initTunnel() {
    path = [];
    
    path.push({ z: 0, centerX: 0, centerY: 0, rotation: 0, isAnchor: true });
    
    for(let i=0; i < 5; i++) {
        generateNextPathPoint();
    }

    let currentZ = 0;
    const maxZ = path[path.length - 1].z;
    
    while(currentZ < maxZ) {
        currentZ += SEGMENT_DEPTH;

        const p1 = path.filter(p => p.isAnchor && p.z <= currentZ)
                       .sort((a, b) => b.z - a.z)[0]; 

        const p2 = path.filter(p => p.isAnchor && p.z > currentZ)
                     .sort((a, b) => a.z - b.z)[0]; 

        if (p1 && p2 && currentZ < p2.z) {
            const t = ((currentZ - p1.z) / (p2.z - p1.z)); 
            
            const x = p1.centerX + (p2.centerX - p1.centerX) * t;
            const y = p1.centerY + (p2.centerY - p1.centerY) * t;
            const r = p1.rotation + (p2.rotation - p1.rotation) * t;
            
            path.push({
                z: currentZ,
                centerX: x,
                centerY: y,
                rotation: r,
                isAnchor: false
            });
        }
    }
    path.sort((a, b) => a.z - b.z);
}

function initGame() {
    initTunnel();
    speed = BASE_SPEED;
    score = 0;
    playerX = 0;
    playerY = 0;
    targetX = 0;
    targetY = 0;
    hue = 0;
    
    gameState = 'PLAYING'; 
}

// Request gyroscope permission for iOS 13+
async function requestGyroPermission() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission === 'granted') {
                enableGyroscope();
            }
        } catch (error) {
            console.log('Gyroscope permission denied');
        }
    } else {
        enableGyroscope();
    }
}

function enableGyroscope() {
    window.addEventListener('deviceorientation', handleGyroscope);
    isGyroActive = true;
}

function handleGyroscope(e) {
    if (gameState !== 'PLAYING' || !isGyroActive) return;
    
    // beta: front-back tilt (-180 to 180), gamma: left-right tilt (-90 to 90)
    const beta = e.beta || 0;   // Forward/backward
    const gamma = e.gamma || 0; // Left/right

    // Set baseline on first read
    if (gyroBaseX === 0 && gyroBaseY === 0) {
        gyroBaseX = gamma;
        gyroBaseY = beta;
    }

    // Calculate relative tilt from baseline
    const deltaX = (gamma - gyroBaseX) * GYRO_SENSITIVITY;
    const deltaY = (beta - gyroBaseY) * GYRO_SENSITIVITY;

    // Update target position based on tilt
    targetX = Math.max(-WIDTH/2, Math.min(WIDTH/2, deltaX * 10));
    targetY = Math.max(-HEIGHT/2, Math.min(HEIGHT/2, deltaY * 10));
}

// Mouse/Cursor Control (Desktop fallback)
gameContainer.addEventListener('mousemove', handleCursorMove);
gameContainer.addEventListener('touchmove', handleCursorMove);

function handleCursorMove(e) {
    if (gameState !== 'PLAYING') return;
    
    // Only use cursor if gyroscope is not active
    if (isGyroActive) return;
    
    e.preventDefault(); 
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);

    const screenCenterOffsetX = clientX - WIDTH / 2;
    const screenCenterOffsetY = clientY - HEIGHT / 2;

    targetX = screenCenterOffsetX * SENSITIVITY_SCALE;
    targetY = screenCenterOffsetY * SENSITIVITY_SCALE;
}

let lastTime = 0;

function gameLoop(timestamp) {
    if (gameState === 'START') {
        render();
        requestAnimationFrame(gameLoop);
        return;
    }

    const dt = (timestamp - lastTime) / 16.66;
    lastTime = timestamp;

    if (gameState === 'PLAYING') {
        update(dt);
    }
    render();

    requestAnimationFrame(gameLoop);
}

function update(dt) {
    playerX += (targetX - playerX) * SMOOTHING_FACTOR * dt;
    playerY += (targetY - playerY) * SMOOTHING_FACTOR * dt;

    playerX = Math.max(-WIDTH/2, Math.min(WIDTH/2, playerX));
    playerY = Math.max(-HEIGHT/2, Math.min(HEIGHT/2, playerY));

    speed += 0.005 * dt;
    score += Math.floor(speed * dt);
    hue = (hue + 0.5 * dt) % 360;

    const moveZ = speed * dt;
    
    for (let i = 0; i < path.length; i++) {
        path[i].z -= moveZ;
    }

    while (path.length > 0 && path[0].z < -ANCHOR_SPACING) {
        path.shift();
    }
    
    if (path.length > 0) {
        let closestSegment = null;
        for (const segment of path) {
            if (!segment.isAnchor && segment.z > 0) {
                closestSegment = segment;
                break;
            }
        }
        
        if (closestSegment) {
            checkCollision(closestSegment);
        }
    }

    const maxZNeeded = 5 * ANCHOR_SPACING;
    const farthestZ = path.length > 0 ? path[path.length - 1].z : 0;
    
    if (farthestZ < maxZNeeded) {
        generateNextPathPoint();
        
        const anchors = path.filter(p => p.isAnchor).sort((a, b) => a.z - b.z);
        const p1 = anchors[anchors.length - 2];
        const p2 = anchors[anchors.length - 1];
        
        if (p1 && p2) {
            let currentInterpolationZ = p1.z;
            while (currentInterpolationZ < p2.z - SEGMENT_DEPTH) {
                currentInterpolationZ += SEGMENT_DEPTH;

                const t = ((currentInterpolationZ - p1.z) / (p2.z - p1.z)); 
                
                const x = p1.centerX + (p2.centerX - p1.centerX) * t;
                const y = p1.centerY + (p2.centerY - p1.centerY) * t;
                const r = p1.rotation + (p2.rotation - p1.rotation) * t;
                
                path.push({
                    z: currentInterpolationZ,
                    centerX: x,
                    centerY: y,
                    rotation: r,
                    isAnchor: false
                });
            }
            path.sort((a, b) => a.z - b.z);
        }
    }

    document.getElementById('scoreDisplay').innerText = Math.floor(score / 100);
    let mach = (speed / BASE_SPEED).toFixed(1);
    document.getElementById('speedDisplay').innerText = `MACH ${mach}`;
}

function checkCollision(segment) {
    const dx = playerX - segment.centerX;
    const dy = playerY - segment.centerY;

    const distanceToCenter = Math.sqrt(dx * dx + dy * dy);

    const innerRadius = TUNNEL_RADIUS * WALL_THICKNESS;

    if (distanceToCenter > innerRadius) {
        crash();
    }
}

function crash() {
    gameState = 'GAMEOVER';
    speed = 0;
    playSound('crash');
    
    // Vibration on crash (mobile devices)
    if ('vibrate' in navigator) {
        navigator.vibrate([200, 100, 200]); // Vibrate pattern: 200ms, pause 100ms, 200ms
    }
    
    canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
    setTimeout(() => canvas.style.transform = 'none', 50);
    
    document.getElementById('ui-layer').classList.add('hidden');
    document.getElementById('finalScore').innerText = Math.floor(score / 100);
    document.getElementById('gameOverScreen').classList.remove('hidden');
    gameContainer.style.cursor = 'auto';
}

function render() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    const cx = WIDTH / 2;
    const cy = HEIGHT / 2;
    
    const maxZ = path.reduce((max, p) => Math.max(max, p.z), 0);

    for (let i = path.length - 2; i >= 0; i--) {
        const seg1 = path[i];
        const seg2 = path[i + 1];
        
        if (seg1.z < 1 || seg2.z < 1) continue; 

        drawTunnelSegment(cx, cy, seg1, seg2, maxZ);
    }
    
    ctx.save();
    ctx.translate(cx + playerX, cy + playerY);
    
    ctx.shadowBlur = 20;
    ctx.shadowColor = 'rgba(0, 255, 255, 0.8)';
    ctx.fillStyle = '#fff';
    
    ctx.beginPath();
    ctx.moveTo(0, -10);
    ctx.lineTo(10, 10);
    ctx.lineTo(-10, 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

function drawTunnelSegment(cx, cy, seg1, seg2, maxZ) {
    const scale1 = FOV / seg1.z;
    const scale2 = FOV / seg2.z;

    const outerRadius1 = TUNNEL_RADIUS * scale1;
    const innerRadius1 = outerRadius1 * WALL_THICKNESS;
    
    const outerRadius2 = TUNNEL_RADIUS * scale2;
    const innerRadius2 = outerRadius2 * WALL_THICKNESS;

    const normalizedDepth = seg2.z / maxZ;
    const lineBrightness = 60 + (1 - normalizedDepth) * 35;
    const lineWidth = 1 + scale2 * 0.5; 
    const blurAmount = Math.max(0, 6 * scale2); 

    for (let j = 0; j < SIDES; j++) {
        const angle1_a = j * (Math.PI / 3) + seg1.rotation;
        const angle1_b = (j + 1) * (Math.PI / 3) + seg1.rotation;
        const angle2_a = j * (Math.PI / 3) + seg2.rotation;

        const P3_I = { x: cx + seg2.centerX * scale2 + Math.cos(angle2_a) * innerRadius2, y: cy + seg2.centerY * scale2 + Math.sin(angle2_a) * innerRadius2 };
        
        const P1_I = { x: cx + seg1.centerX * scale1 + Math.cos(angle1_a) * innerRadius1, y: cy + seg1.centerY * scale1 + Math.sin(angle1_a) * innerRadius1 };
        const P2_I = { x: cx + seg1.centerX * scale1 + Math.cos(angle1_b) * innerRadius1, y: cy + seg1.centerY * scale1 + Math.sin(angle1_b) * innerRadius1 };

        ctx.strokeStyle = `hsl(${hue + j * 10}, 100%, ${lineBrightness}%)`;
        
        ctx.shadowBlur = blurAmount; 
        ctx.shadowColor = ctx.strokeStyle;
        ctx.lineWidth = lineWidth; 

        ctx.beginPath();
        ctx.moveTo(P3_I.x, P3_I.y);
        ctx.lineTo(P2_I.x, P2_I.y);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(P3_I.x, P3_I.y);
        ctx.lineTo(P1_I.x, P1_I.y);
        ctx.stroke();
    }
    ctx.shadowBlur = 0;
}

function startGame() {
    initGame(); 
    
    // Request gyroscope permission on mobile
    requestGyroPermission();
    
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    gameContainer.style.cursor = 'none';
    
    if (audioCtx.state === 'suspended') audioCtx.resume();
    lastTime = performance.now();
}

function resetGame() {
    // Reset gyroscope baseline
    gyroBaseX = 0;
    gyroBaseY = 0;
    
    document.getElementById('gameOverScreen').classList.add('hidden');
    startGame(); 
}

window.onload = function () {
    resize();
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,WIDTH, HEIGHT);
    requestAnimationFrame(gameLoop); 
}
</script>
</body>
</html>