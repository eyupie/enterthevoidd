<!DOCTYPE html>
<html lang="en">
<head>
        <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TJL2LTC5MD"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-TJL2LTC5MD');
    </script>
    <link rel="manifest" href="/manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: white;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            background: #000;
            overflow: hidden;
            user-select: none;
            cursor: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .score-container {
            text-align: left;
        }

        .score-label {
            font-size: 14px;
            color: #aaa;
            letter-spacing: 2px;
        }

        .score-val {
            font-size: 48px;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .speed-meter {
            text-align: right;
        }

        .speed-val {
            font-size: 24px;
            color: #00ffff;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            z-index: 20;
            transition: opacity 0.3s;
            padding: 20px;
            box-sizing: border-box;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 64px;
            margin: 0;
            letter-spacing: 5px;
            background: linear-gradient(90deg, #ff0055, #00ffff, #00ff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.5)); }
            50% { filter: drop-shadow(0 0 40px rgba(255, 0, 85, 0.8)); }
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 36px;
                letter-spacing: 2px;
            }
            
            .game-over-title {
                font-size: 18px !important;
                letter-spacing: 0.5px !important;
                line-height: 1.2;
                text-align: center;
                padding: 0 15px;
                white-space: nowrap;
            }
        }

        p {
            color: #ccc;
            font-size: 18px;
            margin-top: 10px;
            max-width: 500px;
            text-align: center;
            line-height: 1.6;
        }

        .btn {
            margin-top: 40px;
            padding: 20px 60px;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            background: transparent;
            border: 3px solid #fff;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }

        .controls-hint {
            margin-top: 30px;
            font-size: 14px;
            color: #666;
            display: flex;
            gap: 20px;
        }

        .key {
            border: 1px solid #666;
            padding: 5px 10px;
            border-radius: 4px;
            color: #aaa;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" class="ui-layer hidden">
        <div class="hud-top">
            <div class="score-container">
                <div class="score-label">DISTANCE</div>
                <div class="score-val" id="scoreDisplay">0</div>
            </div>
            <div class="speed-meter">
                <div class="score-label">VELOCITY</div>
                <div class="speed-val" id="speedDisplay">MACH 1</div>
            </div>
        </div>
    </div>

    <div id="startScreen" class="screen">
        <h1>VOID</h1>
        <p>Enter the void. Get lost.</p>
        
        <div class="controls-hint">
            <span><span class="key">TILT / CURSOR</span> STEER SHIP</span>
        </div>

        <button class="btn" onclick="startGame()">ENTER THE VOID</button>
    </div>

    <div id="gameOverScreen" class="screen hidden">
        <h1 class="game-over-title" style="font-size: 48px; color: #ff0055; -webkit-text-fill-color: #ff0055;">CATASTROPHIC DENSITY</h1>
        <p>You reached <span id="finalScore" style="color:white; font-weight:bold;">0</span>m</p>
        <button class="btn" onclick="resetGame()">RESTART</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');

const SIDES = 6;
const FOV = 800;
const SEGMENT_DEPTH = 20; // Reduced from 30 for more frequent segments
const WALL_THICKNESS = 0.8;
const TUNNEL_RADIUS = 300;
const MAX_PATH_DEVIATION = 150;
const ANCHOR_SPACING = SEGMENT_DEPTH * 10;

let WIDTH, HEIGHT;

let gameState = 'START';
let score = 0;
let speed = 0;
const BASE_SPEED = 8; 
let hue = 0;

let playerX = 0;
let playerY = 0;
let targetX = 0;
let targetY = 0;

// Camera offset for parallax effect
let cameraOffsetX = 0;
let cameraOffsetY = 0;

const SENSITIVITY_SCALE = 0.5;
const SMOOTHING_FACTOR = 0.15;

// Gyroscope variables
let isGyroActive = false;
let gyroBaseX = 0;
let gyroBaseY = 0;
const GYRO_SENSITIVITY = 0.6;

// Particle system for enhanced visuals
let particles = [];
const MAX_PARTICLES = 60; // Reduced for performance

let path = [];

const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    const now = audioCtx.currentTime;

    if (type === 'crash') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
    }
}

function resize() {
    WIDTH = canvas.parentElement.clientWidth;
    HEIGHT = canvas.parentElement.clientHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    
    playerX = Math.max(-WIDTH/2, Math.min(WIDTH/2, playerX));
    playerY = Math.max(-HEIGHT/2, Math.min(HEIGHT/2, playerY));
}
window.addEventListener('resize', resize);
resize();

// Particle system
function createParticle() {
    return {
        x: Math.random() * WIDTH,
        y: Math.random() * HEIGHT,
        z: Math.random() * 1000 + 500,
        speed: Math.random() * 2 + 1,
        size: Math.random() * 2 + 1,
        brightness: Math.random() * 0.5 + 0.5
    };
}

function initParticles() {
    particles = [];
    for (let i = 0; i < MAX_PARTICLES; i++) {
        particles.push(createParticle());
    }
}

function updateParticles(dt) {
    for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.z -= speed * dt * 2;
        
        if (p.z < 1) {
            particles[i] = createParticle();
        }
    }
}

function drawParticles() {
    for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const scale = FOV / p.z;
        const x = (p.x - WIDTH / 2) * scale + WIDTH / 2;
        const y = (p.y - HEIGHT / 2) * scale + HEIGHT / 2;
        const size = p.size * scale;
        
        if (x > 0 && x < WIDTH && y > 0 && y < HEIGHT) {
            const alpha = p.brightness * (1 - p.z / 1500);
            ctx.fillStyle = `hsla(${hue}, 100%, 80%, ${alpha})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

function generateNextPathPoint() {
    const latestAnchor = path.filter(p => p.isAnchor).sort((a, b) => b.z - a.z)[0] || 
                         { z: -ANCHOR_SPACING, centerX: 0, centerY: 0, rotation: 0, isAnchor: true };
                         
    const nextZ = latestAnchor.z + ANCHOR_SPACING;

    // Back to original turning intensity
    const newX = latestAnchor.centerX + (Math.random() - 0.5) * 200;
    const newY = latestAnchor.centerY + (Math.random() - 0.5) * 200;
    
    const clampedX = Math.max(-MAX_PATH_DEVIATION, Math.min(MAX_PATH_DEVIATION, newX));
    const clampedY = Math.max(-MAX_PATH_DEVIATION, Math.min(MAX_PATH_DEVIATION, newY));

    const newRotation = latestAnchor.rotation + (Math.random() - 0.5) * 0.5;

    // Change hue significantly for each new tunnel section
    hue = (hue + 60 + Math.random() * 40) % 360;

    path.push({
        z: nextZ,
        centerX: clampedX,
        centerY: clampedY,
        rotation: newRotation,
        isAnchor: true 
    });

    path.sort((a, b) => a.z - b.z);
}

function initTunnel() {
    path = [];
    
    path.push({ z: 0, centerX: 0, centerY: 0, rotation: 0, isAnchor: true });
    
    for(let i=0; i < 5; i++) {
        generateNextPathPoint();
    }

    let currentZ = 0;
    const maxZ = path[path.length - 1].z;
    
    while(currentZ < maxZ) {
        currentZ += SEGMENT_DEPTH;

        const p1 = path.filter(p => p.isAnchor && p.z <= currentZ)
                       .sort((a, b) => b.z - a.z)[0]; 

        const p2 = path.filter(p => p.isAnchor && p.z > currentZ)
                     .sort((a, b) => a.z - b.z)[0]; 

        if (p1 && p2 && currentZ < p2.z) {
            const t = ((currentZ - p1.z) / (p2.z - p1.z)); 
            
            const x = p1.centerX + (p2.centerX - p1.centerX) * t;
            const y = p1.centerY + (p2.centerY - p1.centerY) * t;
            const r = p1.rotation + (p2.rotation - p1.rotation) * t;
            
            path.push({
                z: currentZ,
                centerX: x,
                centerY: y,
                rotation: r,
                isAnchor: false
            });
        }
    }
    path.sort((a, b) => a.z - b.z);
}

function initGame() {
    initTunnel();
    initParticles();
    speed = BASE_SPEED;
    score = 0;
    playerX = 0;
    playerY = 0;
    targetX = 0;
    targetY = 0;
    hue = 0;
    
    gameState = 'PLAYING'; 
}

async function requestGyroPermission() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission === 'granted') {
                enableGyroscope();
            }
        } catch (error) {
            console.log('Gyroscope permission denied');
        }
    } else {
        enableGyroscope();
    }
}

function enableGyroscope() {
    window.addEventListener('deviceorientation', handleGyroscope);
    isGyroActive = true;
}

function handleGyroscope(e) {
    if (gameState !== 'PLAYING' || !isGyroActive) return;
    
    const beta = e.beta || 0;
    const gamma = e.gamma || 0;

    if (gyroBaseX === 0 && gyroBaseY === 0) {
        gyroBaseX = gamma;
        gyroBaseY = beta;
    }

    const deltaX = (gamma - gyroBaseX) * GYRO_SENSITIVITY;
    const deltaY = (beta - gyroBaseY) * GYRO_SENSITIVITY;

    targetX = Math.max(-WIDTH/2, Math.min(WIDTH/2, deltaX * 10));
    targetY = Math.max(-HEIGHT/2, Math.min(HEIGHT/2, deltaY * 10));
}

gameContainer.addEventListener('mousemove', handleCursorMove);
gameContainer.addEventListener('touchmove', handleCursorMove);

function handleCursorMove(e) {
    if (gameState !== 'PLAYING') return;
    
    // Only block cursor if gyroscope is working AND orientation data is being received
    if (isGyroActive && gyroBaseX !== 0) return;
    
    if (e.cancelable) e.preventDefault(); 
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);

    const screenCenterOffsetX = clientX - WIDTH / 2;
    const screenCenterOffsetY = clientY - HEIGHT / 2;

    targetX = screenCenterOffsetX * SENSITIVITY_SCALE;
    targetY = screenCenterOffsetY * SENSITIVITY_SCALE;
}

let lastTime = 0;

function gameLoop(timestamp) {
    if (gameState === 'START') {
        render();
        requestAnimationFrame(gameLoop);
        return;
    }

    const dt = (timestamp - lastTime) / 16.66;
    lastTime = timestamp;

    if (gameState === 'PLAYING') {
        update(dt);
    }
    render();

    requestAnimationFrame(gameLoop);
}

function update(dt) {
    playerX += (targetX - playerX) * SMOOTHING_FACTOR * dt;
    playerY += (targetY - playerY) * SMOOTHING_FACTOR * dt;

    playerX = Math.max(-WIDTH/2, Math.min(WIDTH/2, playerX));
    playerY = Math.max(-HEIGHT/2, Math.min(HEIGHT/2, playerY));

    // Camera parallax effect - screen moves more with player movement
    cameraOffsetX += (playerX * 0.35 - cameraOffsetX) * 0.15 * dt;
    cameraOffsetY += (playerY * 0.35 - cameraOffsetY) * 0.15 * dt;

    speed += 0.005 * dt;
    score += Math.floor(speed * dt);

    updateParticles(dt);

    const moveZ = speed * dt;
    
    for (let i = 0; i < path.length; i++) {
        path[i].z -= moveZ;
    }

    while (path.length > 0 && path[0].z < -ANCHOR_SPACING) {
        path.shift();
    }
    
    if (path.length > 0) {
        let closestSegment = null;
        for (const segment of path) {
            if (!segment.isAnchor && segment.z > 0) {
                closestSegment = segment;
                break;
            }
        }
        
        if (closestSegment) {
            checkCollision(closestSegment);
        }
    }

    const maxZNeeded = 5 * ANCHOR_SPACING;
    const farthestZ = path.length > 0 ? path[path.length - 1].z : 0;
    
    if (farthestZ < maxZNeeded) {
        generateNextPathPoint();
        
        const anchors = path.filter(p => p.isAnchor).sort((a, b) => a.z - b.z);
        const p1 = anchors[anchors.length - 2];
        const p2 = anchors[anchors.length - 1];
        
        if (p1 && p2) {
            let currentInterpolationZ = p1.z;
            while (currentInterpolationZ < p2.z - SEGMENT_DEPTH) {
                currentInterpolationZ += SEGMENT_DEPTH;

                const t = ((currentInterpolationZ - p1.z) / (p2.z - p1.z)); 
                
                const x = p1.centerX + (p2.centerX - p1.centerX) * t;
                const y = p1.centerY + (p2.centerY - p1.centerY) * t;
                const r = p1.rotation + (p2.rotation - p1.rotation) * t;
                
                path.push({
                    z: currentInterpolationZ,
                    centerX: x,
                    centerY: y,
                    rotation: r,
                    isAnchor: false
                });
            }
            path.sort((a, b) => a.z - b.z);
        }
    }

    document.getElementById('scoreDisplay').innerText = Math.floor(score / 100);
    let mach = (speed / BASE_SPEED).toFixed(1);
    document.getElementById('speedDisplay').innerText = `MACH ${mach}`;
}

function checkCollision(segment) {
    const dx = playerX - segment.centerX;
    const dy = playerY - segment.centerY;

    const distanceToCenter = Math.sqrt(dx * dx + dy * dy);

    const innerRadius = TUNNEL_RADIUS * WALL_THICKNESS;

    if (distanceToCenter > innerRadius) {
        crash();
    }
}

function crash() {
    gameState = 'GAMEOVER';
    speed = 0;
    playSound('crash');
    
    if ('vibrate' in navigator) {
        navigator.vibrate([200, 100, 200]);
    }
    
    canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
    setTimeout(() => canvas.style.transform = 'none', 50);
    
    document.getElementById('ui-layer').classList.add('hidden');
    document.getElementById('finalScore').innerText = Math.floor(score / 100);
    document.getElementById('gameOverScreen').classList.remove('hidden');
    gameContainer.style.cursor = 'auto';
}

function render() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Apply camera offset for parallax effect
    ctx.save();
    ctx.translate(cameraOffsetX, cameraOffsetY);

    // Draw particles first (background layer)
    drawParticles();

    const cx = WIDTH / 2;
    const cy = HEIGHT / 2;
    
    const maxZ = path.reduce((max, p) => Math.max(max, p.z), 0);

    // Cache frequently used values
    const pathLen = path.length;
    
    for (let i = pathLen - 2; i >= 0; i--) {
        const seg1 = path[i];
        const seg2 = path[i + 1];
        
        if (seg1.z < 1 || seg2.z < 1) continue; 

        drawTunnelSegment(cx, cy, seg1, seg2, maxZ);
    }
    
    // Draw ship with enhanced glow
    ctx.save();
    ctx.translate(cx + playerX, cy + playerY);
    
    // Multiple glow layers for intense effect
    ctx.shadowBlur = 30;
    ctx.shadowColor = `hsla(${hue}, 100%, 60%, 0.8)`;
    ctx.fillStyle = '#fff';
    
    ctx.beginPath();
    ctx.moveTo(0, -10);
    ctx.lineTo(10, 10);
    ctx.lineTo(-10, 10);
    ctx.closePath();
    ctx.fill();
    
    // Second glow layer
    ctx.shadowBlur = 50;
    ctx.shadowColor = `hsla(${hue + 180}, 100%, 60%, 0.5)`;
    ctx.fill();
    
    ctx.restore();
    
    // Restore camera transform
    ctx.restore();
}

function drawTunnelSegment(cx, cy, seg1, seg2, maxZ) {
    const scale1 = FOV / seg1.z;
    const scale2 = FOV / seg2.z;

    const outerRadius1 = TUNNEL_RADIUS * scale1;
    const innerRadius1 = outerRadius1 * WALL_THICKNESS;
    
    const outerRadius2 = TUNNEL_RADIUS * scale2;
    const innerRadius2 = outerRadius2 * WALL_THICKNESS;

    const normalizedDepth = seg2.z / maxZ;
    const lineBrightness = 70 + (1 - normalizedDepth) * 30;
    const lineWidth = 1.5 + scale2 * 0.6;
    const blurAmount = Math.max(0, 12 * scale2);

    // Single color for entire segment - based on segment depth
    const segmentHue = (hue + (seg2.z * 0.3)) % 360;
    ctx.strokeStyle = `hsl(${segmentHue}, 100%, ${lineBrightness}%)`;
    ctx.shadowBlur = blurAmount; 
    ctx.shadowColor = ctx.strokeStyle;
    ctx.lineWidth = lineWidth;

    const PI_THIRD = Math.PI / 3;
    
    for (let j = 0; j < SIDES; j++) {
        const angle1_a = j * PI_THIRD + seg1.rotation;
        const angle1_b = (j + 1) * PI_THIRD + seg1.rotation;
        const angle2_a = j * PI_THIRD + seg2.rotation;

        const cos2a = Math.cos(angle2_a);
        const sin2a = Math.sin(angle2_a);
        const cos1a = Math.cos(angle1_a);
        const sin1a = Math.sin(angle1_a);
        const cos1b = Math.cos(angle1_b);
        const sin1b = Math.sin(angle1_b);

        const centerX2Scaled = seg2.centerX * scale2;
        const centerY2Scaled = seg2.centerY * scale2;
        const centerX1Scaled = seg1.centerX * scale1;
        const centerY1Scaled = seg1.centerY * scale1;

        const P3_I = { 
            x: cx + centerX2Scaled + cos2a * innerRadius2, 
            y: cy + centerY2Scaled + sin2a * innerRadius2 
        };
        
        const P1_I = { 
            x: cx + centerX1Scaled + cos1a * innerRadius1, 
            y: cy + centerY1Scaled + sin1a * innerRadius1 
        };
        
        const P2_I = { 
            x: cx + centerX1Scaled + cos1b * innerRadius1, 
            y: cy + centerY1Scaled + sin1b * innerRadius1 
        };

        ctx.beginPath();
        ctx.moveTo(P3_I.x, P3_I.y);
        ctx.lineTo(P2_I.x, P2_I.y);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(P3_I.x, P3_I.y);
        ctx.lineTo(P1_I.x, P1_I.y);
        ctx.stroke();
    }
    ctx.shadowBlur = 0;
}

function startGame() {
    initGame(); 
    
    requestGyroPermission();
    
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    gameContainer.style.cursor = 'none';
    
    if (audioCtx.state === 'suspended') audioCtx.resume();
    lastTime = performance.now();
}

function resetGame() {
    gyroBaseX = 0;
    gyroBaseY = 0;
    
    document.getElementById('gameOverScreen').classList.add('hidden');
    startGame(); 
}

window.onload = function () {
    resize();
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,WIDTH, HEIGHT);
    requestAnimationFrame(gameLoop); 
}
</script>
</body>
</html>